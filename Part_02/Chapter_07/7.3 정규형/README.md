# 7.3 정규형

<br/>

관계형 데이터베이스를 설계하는 데 사용할 수 있는 다양한 정규형이 존재한다.

- `제1정규형` : 분해가 아닌 속성의 도메인과 관련된다. (7.8절)
- `제2정규형` : 역사적으로만 중요성을 지니고 실제로는 제3정규형 또는 BCNF 중 하나가 항상 더 좋은 선택이다. (책에서는 생략되었음)
- `BCNF`
- `제3정규형`

<br/>
<br/>
<br/>

# 7.3.1 보이스-코드 정규형

`보이스-코드 정규형(Boyce-Codd Normal Form, BCNF)`은 **함수 종속을 기반으로 발견할 수 있는 모든 중복을 제거**하지만, 다른 유형의 중복이 남을 수 있다.

<br/>

## 7.3.1.1 정의

R는 스키마, F는 함수 종속의 집합이라고 하자.

<br/>

만약 **α ⊆ R이고 β ⊆ R인 α → β 형태의 F+의 모든 함수 종속**이 다음 중 적어도 하나라도 만족한다면  
함수 종속의 집합 F와 관련하여 릴레이션 스키마 R는 BCNF에 있다.

- α → β가 자명한(trivial) 함수 종속이다. (즉, β ⊆ α)
- α가 스키마 R의 수퍼 키다.

<br/>

설계를 구성하고 있는 모든 릴레이션이 BCNF에 속하면 그 데이터베이스 설계는 BCNF에 속한다.

<br/>

e.g., instructor 스키마는 BCNF에 속한다.

`ID → name, dept_name, salary` (자명하지 않은 모든 함수 종속은 화살표 왼쪽에 ID를 포함하여 성립함)

- ID는 instructor에 대한 수퍼 키다. (사실 이 경우는 주 키)
- 즉, 화살표 왼쪽에 ID를 포함하지 않고 `name, dept_name, salary`의 조합만으로 구성된 자명하지 않은 함수 종속이 존재하지 않는다.
- 따라서 instructor는 BCNF에 속한다.

<br/>

### BCNF 형태가 아닌 스키마를 분해하는 규칙

R가 BCNF가 아닌 스키마이며 자명하지 않은 함수 종속 α → β가 최소 한 개 존재하고, α는 R에 대한 수퍼 키가 아니라고 하자.

<br/>

설계에서 R를 다음과 같은 두 개의 스키마로 대체할 수 있다.

- (α ⋃ β)
- (R - (β - α))

<br/>

BCNF가 아닌 스키마를 분해할 때 그 결과로 나오는 스키마들 중 하나 혹은 그 이상은 BCNF가 아닐 수도 있다.

이럴 경우, 계속해서 분해를 수행하여 궁극적인 결과가 BCNF 스키마의 집합이 되도록 한다.

<br/>

---

<br/>

e.g.,

```sql
in_dep (ID, name, salary, dept_name, building, budget)
```

<br/>

위 스키마의 경우, α와 β는 다음과 같다.

α = dept_name

β = { building, budget }

<br/>

in_dep는 다음과 같이 대체할 수 있다.

- (α ⋃ β) = (dept_name, building, budget)
- (R - (β - α)) = (ID, name, dept_name, salary)

<br/>
<br/>

## 7.3.1.2 BCNF와 종속성 보존

데이터베이스 일관성 제약 조건을 표현하기 위한 방법으로는 주 키 제약 조건, 함수 종속, check 제약 조건, 주장, 트리거 등이 있다.

데이터베이스가 갱신될 때마다 이러한 제약 조건을 검사하는 것은 큰 비용이 소모될 수 있기에,  
제약 조건을 효과적으로 검사할 수 있는 방법으로 데이터베이스를 설계하는 것이 유용하다.

> 여기서는 **BCNF로 분해하는 작업이 어떤 함수 종속을 효과적으로 검사하는 것을 방해할 수도 있다**는 것을 살펴본다.

<br/>

```
BCNF can decompose “too much”
```

<br/>

예를 들어, 대학교 조직을 운용하는 방식에 변화를 준다고 가정해보자.

- 원래 설계에서는 한 명의 학생이 반드시 단 한 명의 지도교수를 둘 수 있었다. (이는 student로부터 advisor로 다대일인 advisor 관계 집합에 기인함)
- 이제 교수는 단일 부서에만 연관될 수 있고,  
  **한 학생은 두 명 이상의 지도교수를 둘 수 있지만 주어진 학과에서는 최대 한 명만 가능하도록** 할 것이다. (복수 전공 제도를 도입)

<br/>

이런 변화를 E-R 설계로 구현하는 한 가지 방법은  
`advisor 관계 집합`을 세 개의 개체 집합 instructor, student, department를 포함하는 `삼진 관계 집합 dept_advisor`로 대체하는 것이다.

<br/>

<p align="center"><img width="520" alt="dept_advisor" src="https://user-images.githubusercontent.com/86337233/226106157-9d36d8bf-76ed-4739-a4a2-1f904b2209ae.png">

<br/>
<br/>

dept_advisor 관계 집합을 다음 스키마로 변환할 수 있다.

```sql
dept_advisor (s_ID, i_ID, dept_name)
```

<br/>

E-R 다이어그램에는 구체적으로 명시되어 있진 않지만,  
’**교수는 단 하나의 학과에서만 지도교수로 활동할 수 있다**’라는 추가적인 제약 조건이 있다고 가정해보자.

그러면 다음의 함수 종속은 dept_advisor에서 유지된다.

```sql
i_ID → dept_name
// '교수는 단 하나의 학과에서만 지도교수로 활동할 수 있다'는 요구 사항에서 나옴

s_ID, dept_name → i_ID
// '학생은 주어진 학과에 대해서 많아야 한 명의 지도교수를 둘 수 있다'는 요구 사항에서 나옴
```

**이 설계에서 교수가 dept_advisor 관계에 참여할 때마다 학과명을 반복해야 한다.**

<br/>

따라서 `BCNF 분해 규칙`을 dept_advisor에 적용하면 다음을 얻을 수 있다.

- (s_ID, i_ID)
- (i_ID, dept_name)

<br/>

두 스키마 모두 BCNF를 만족한다.

> 하지만 함수 종속 `s_ID, dept_name → i_ID`에 나타나는 세 가지 속성을 포함하는 스키마는 존재하지 않는다.

- 분해한 개별 릴레이션에 적용할 수 있는 유일한 종속성은 `i_ID → dept_name`이다.
- `s_ID, dept_name → i_ID`는 분해된 릴레이션의 조인을 계산해야 검사할 수 있다.

<br/>

---

<br/>

위 설계는 조인 없이 이 함수 종속의 적용을 허용하지 않기 때문에 이 설계는 `종속성을 보존(dependency preserving)하지 않는다`고 말한다.

<br/>

> 종속성 보존을 보통 바람직한 것으로 간주하기 때문에, BCNF보다는 약하지만 종속성을 보존하는 다른 형태의 정규형을 고려할 필요도 있다.

→ `제3정규형`

<br/>
<br/>
<br/>

# 7.3.2 제3정규형

BCNF은 모든 비자명한(nontrivial) 종속은 α → β의 형태여야 하고, 이때 α가 수퍼 키임을 요구한다.

> `제3정규형(3NF)`은 **비자명한 함수 종속에 대해 그 좌측 항이 수퍼 키가 아닌 것도 허용**함으로써 제약 조건을 조금 완화했다.

<br/>

릴레이션 스키마 R는 관련된 함수 종속들의 집합 F에 대해서 제3정규형(3NF)이라 하는데,  
이때 α ⊆ R, β ⊆ R이며 α → β 형태를 갖는 F+의 모든 함수 종속이 다음 중 적어도 하나를 만족해야 한다.

- α → β는 자명한 함수 종속이다.
- α는 R의 수퍼 키다.
- **β - α에 속한 각 속성 A는 R의 후보 키에 포함된다.**
    - 후보 키는 최소의 수퍼 키이다.
    - 단일 후보 키가 β - α의 모든 속성을 포함해야 한다는 것을 의미하는 것은 아니며, **β - α에 속하는 각 속성 A가 서로 다른 후보 키에 포함될 수 있다.**

<br/>

세 번째 조건은 직관적이지도 않고, 이것이 왜 유용한지도 명확하지 않는데  
이는 어떤 의미에서 **모든 스키마를 3NF로 종속성 보존 분해할 수 있도록 보장하기 위해 BCNF의 조건을 최소한으로 완화했음**을 나타낸다.

세 번째 조건의 목적은 3NF로의 분해에 대해 설명할 때 더 명확해질 것이다. (7.5.2절)

<br/>

---

<br/>

> BCNF를 만족하는 스키마는 그것의 함수 종속 각각이 위의 두 가지 조건 중 하나를 만족하기 때문에 3NF를 만족한다.

- 따라서 BCNF는 3NF보다 더 제한적이며 까다로운 조건을 가진 정규형이다.
- 3NF의 정의는 BCNF가 허용하지 않는 어떤 함수 종속을 허용한다.

<br/>

다음의 함수 종속을 가지는 dept_advisor 스키마를 다시 살펴보자.

```sql
i_ID → dept_name
// '교수는 단 하나의 학과에서만 지도교수로 활동할 수 있다'는 요구 사항에서 나옴

s_ID, dept_name → i_ID
// '학생은 주어진 학과에 대해서 많아야 한 명의 지도교수를 둘 수 있다'는 요구 사항에서 나옴
```

<br/>

앞서 `i_ID → dept_name`으로 인해 dept_advisor 스키마가 BCNF에 속하지 않는다고 하였다.

- α = i_ID
- β = dept_name
- β - α = dept_name

함수 종속 `s_ID, dept_name → i_ID`는 dept_advisor에서 성립하고, 속성 dept_name은 후보 키에 포함되므로 dept_advisor는 3NF에 속한다.

> 즉, 세 번째 조건은 redundancy를 허락하는 조건이다.

<br/>
<br/>
<br/>

# 7.3.3 BCNF와 3NF의 비교

관계형 데이터베이스 스키마에 대한 두 개의 정규형 3NF와 BCNF 중에서  
**무손실 또는 종속성 보존을 희생하지 않고 항상 3NF 설계를 얻을 수 있다**는 점에서 3NF가 좀 더 유용하다고 말할 수 있다.

그럼에도 불구하고, 3NF는 데이터 항목 간의 생길 수 있는 몇몇 의미적인 연관성을 표현하기 위해 **null 값**을 사용해야 할 수도 있으며,  
**정보 반복 문제**도 가지고 있다.

<br/>

함수 종속을 사용하는 데이터베이스 설계의 목표는 다음과 같다.

1. BCNF
2. 무손실
3. 종속성 보존

<br/>

세 가지를 모두 항상 만족할 수 있는 것은 아니기 때문에 BCNF 또는 종속성 보존을 위한 3NF를 선택해야 한다.
