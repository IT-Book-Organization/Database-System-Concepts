# 14.2 순서 인덱스

<br/>

인덱스 구조는 파일 안에 있는 레코드에 대한 `임의 접근(random access)`**을 빨리 하기 위해서** 사용할 수 있다.

<br/>

### 순서 인덱스, ordered index

> entries are stored on the search key value

**검색 키의 값을 정렬된 순서로 저장**하고, 검색 키와 검색 키를 포함하는 레코드를 연계시킨다.

<br/>

### 클러스터링 인덱스, clustering index, clustered index

> orders of keys in index = sequential order of the file

레코드를 포함하는 파일이 연속적인 순서로 저장되어 있다면,  
클러스터링 인덱스는 **그 파일을 연속적인 순서로 정의한 속성을 검색 키로 사용**하는 인덱스를 말한다.

- 클러스터링 인덱스는 `기본 인덱스(primary index)`라고도 부른다.
- 클러스터링 인덱스의 검색 키는 주 키인 경우가 많지만 반드시 그럴 필요는 없다.

<br/>

### 비클러스터링 인덱스, nonclustering index, nonclustered index

- **파일의 연속적인 순서와 다른 순서**로 구성되는 검색 키의 인덱스를 말한다.
- `보조 인덱스(secondary index)`라고도 부른다.

<br/>

### 인덱스 순차 파일, indexed-sequential file

> sequential file ordered on a search key, with a clustered index on the search key

해당 장의 1절부터 3절까지에서는 **모든 파일은 어떤 검색 키에 의한 연속적인 순서로 정렬되어 있다**고 가정한다.

이렇게 검색 키에 대해 기본 인덱스를 가지는 파일을 `인덱스 순차 파일`이라 부른다.

<br/>
<br/>

## 인덱스 레코드의 구성

- `인덱스 레코드(index record)`, 즉 `인덱스 엔트리(index entry)`는  
  (1) **검색 키 값**과 (2) 이를 검색 키 값으로 가지는 한 개 이상의 레코드에 대한 **포인터**로 구성되어 있다.
- 포인터 : 디스크 블록의 식별자 + 블록 안에서 레코드를 구별하기 위한 오프셋(offset)

<br/>

<p align="center"><img width="300" alt="인덱스 레코드의 구성" src="https://github.com/IT-Book-Organization/Database-System-Concepts/assets/86337233/97a9f2ac-77a6-4698-b218-364a3cc61877">

<br/>
<br/>
<br/>

## 14.2.1 밀집과 희소 인덱스

순서 인덱스는 두 가지 유형이 있다.

- 밀집 인덱스, Dense index
- 희소 인덱스, Sparse index

<br/>

### 밀집 인덱스, Dense index

> 인덱스 엔트리는 파일에 있는 **모든 검색 키 값에 대해** 나타난다.

<br/>

- `밀집 클러스터링 인덱스`  
  \: 인덱스 레코드는 검색 키 값과 **그 검색 키 값의 첫 번째 데이터 레코드에 대한 포인터**를 포함한다.  
  (똑같은 검색 키 값을 가진 나머지 레코드는 첫 번째 레코드 이후부터 연속적으로 저장되기 때문)  
  <br/>

- `밀집 비클러스터링 인덱스`  
  \: 똑같은 검색 키를 가진 **모든** 레코드에 대한 포인터 목록을 저장해야 한다.

<br/>

검색 키가 ID인 밀집 클러스터링 인덱스

<p align="center"><img width="550" alt="밀집 인덱스 - ID" src="https://github.com/IT-Book-Organization/Database-System-Concepts/assets/86337233/23264aa5-7cf9-4b84-bfae-469a3bfb542d">

<br/>
<br/>

검색 키가 dept_name인 밀집 클러스터링 인덱스

<p align="center"><img width="560" alt="밀집 인덱스 - dept_name" src="https://github.com/IT-Book-Organization/Database-System-Concepts/assets/86337233/4a0494e8-8aad-4a5f-8634-94437b052f9f">

<br/>
<br/>

### 희소 인덱스, Sparse index

> 인덱스 엔트리는 검색 키 값에 대해 **단지 몇 개만** 나타난다.

- 희소 인덱스는 오직 릴레이션이 검색 키로 정렬되어 저장될 때 (= 인덱스가 `클러스터링 인덱스`인 경우) 사용될 수 있다.
- 검색 키 값과 **그 검색 키 값의 첫 번째 데이터 레코드에 대한 포인터**를 포함한다.
- 레코드를 위치시키기 위해서는
    1. **찾고자 하는 검색 키보다 작거나 동일한 것 중 가장 큰** 검색 키를 가지는 인덱스 엔트리를 찾는다.
    2. 그 검색 키 엔트리에 의해 가리켜지는 레코드를 시작으로, 그 파일에서 원하는 레코드를 찾을 때까지 포인터를 따라간다.

<br/>

<p align="center"><img width="560" alt="희소 인덱스" src="https://github.com/IT-Book-Organization/Database-System-Concepts/assets/86337233/9df4d485-9813-4887-815f-f5c80df3f488">

<br/>
<br/>

---

<br/>

- 일반적으로 레코드의 위치를 정하기 위해서는 희소 인덱스보다 `밀집 인덱스`를 사용하면 더 **빠르다**.
- 그러나 `희소 인덱스`는 밀집 인덱스보다 **더 적은 공간을 요구해서** 삽입과 삭제에 대한 유지 부담이 더 적다.

이처럼 시스템 설계자는 접근 시간과 공간 부담 사이의 상반관계를 고려해야 한다.

<br/>

좋은 절충안은 **블록당 하나의 인덱스 엔트리를 가지는** `희소 인덱스`를 가지는 것이다.

**데이터베이스 요구를 처리하는 데 드는 비용 중 지배적인 것은 디스크에서 메인 메모리로 블록을 가져오는 데 걸리는 시간**이기 때문에,  
일단 블록을 가져왔으면 전체 블록을 훑어보는 데 걸리는 시간은 대수롭지 않기
때문이다.

<br/>
<br/>

## 14.2.2 다계층 인덱스

인덱스가 메인 메모리에 유지될 만큼 충분히 크기가 작다면 엔트리를 찾는 데 걸리는 검색 시간은 짧다.

하지만 전체 인덱스가 메모리에 유지될 수 없을 만큼 크다면 **필요할 때마다 인덱스 블록을 디스크로부터 가져와야 하고**,  
그다음에 인덱스에서 엔트리를 찾기 위해 여러 개의 디스크 블록을 읽어야 한다.

→ 크기가 큰 인덱스에 대한 검색은 비용이 많이 발생한다.

<br/>

이 문제를 해결하기 위해서는 인덱스를 다른 순차 파일처럼 취급하여  
`내부 인덱스`라고 불리는 **원래의 기본 인덱스에 대한** `희소 외부 인덱스`를 구성할 수 있다.

인덱스 엔트리는 외부 인덱스를 희소하게 분포시키며, 항상 정렬된 순서로 존재한다.

> 두 개 혹은 그 이상의 단계를 가지는 인덱스를 `다계층 인덱스(multilevel index)`라 한다.

<br/>

#### `two-level sparce index`에서 레코드의 위치를 찾기 위한 과정

> outer index : a sparse index of the basic index
> inner index : the basic index file→ points the read data

1. 외부 인덱스상에서 이진 검색을 이용하여 원하는 레코드보다 작거나 같은 검색 키 값 중에서 가장 큰 값을 가지는 레코드를 찾는다.  
   **이 레코드 포인터는 내부 인덱스 블록을 가리킨다.**
2. 해당 포인터가 가리키는 블록을 스캔하여 원하는 레코드보다 작거나 같은 검색 키 값 중에서 가장 큰 값을 가지는 레코드를 찾는다.  
   이 레코드에 있는 포인터는 **찾고자 하는 레코드를 포함하는 파일의 블록을 가리킨다.**

<br/>

<p align="center"><img width="580" alt="보조 인덱스" src="https://github.com/IT-Book-Organization/Database-System-Concepts/assets/86337233/5fa3cb9e-0ac7-4482-9a81-e98bca515680">

<br/>
<br/>
<br/>

## 14.2.3 인덱스 갱신

모든 인덱스는 어떤 레코드가 파일에 **삽입**되거나 파일로부터 **삭제**될 때마다 갱신되어야 한다.

파일 안에 레코드가 **갱신**된 경우에는 갱신에 영향을 받은 검색 키를 소유한 어떤 인덱스도 갱신되어야 한다.

- 하지만 레코드의 갱신은 이전 레코드가 삭제되어 뒤이어 새로운 레코드의 값이 삽입되는 것으로 모델링되며, 인덱스도 삭제된 후 새로운 인덱스가 삽입되는 결과를 보인다.
- 따라서 인덱스에 대한 삽입과 삭제에 대해서만 고려하며, 명시적으로 갱신을 고려하지 않아도 된다.

<br/>

### 14.2.3.1 삽입, insertion

1. 시스템은 삽입되는 레코드의 검색 키 값을 사용해서 **찾기를 수행한다.**
2. 그 다음 해야할 일은 인덱스의 종류에 따라서 다르다.

<br/>

#### 밀집 인덱스

1. **검색 키 값이 인덱스에 없다면,** 시스템은 적당한 위치에 검색 키 값을 가지는 인덱스 엔트리를 삽입한다.
2. 그렇지 않다면,
    1. 만약 인덱스 엔트리가 **똑같은 검색 키 값을 가지는 모든 레코드를 가리키는 포인터를 저장하고 있다면,**  
       시스템은 인덱스 엔트리에 새로운 레코드에 대한 포인터를 추가한다.
    2. 그렇지 않다면 인덱스 엔트리는 검색 키 값을 가지는 첫 번째 레코드에 대한 포인터만 저장하고 있다는 것이다.  
       → 시스템은 똑같은 검색 키 값을 가지는 다른 레코드 뒤에 삽입된 레코드를 놓는다.

<br/>

#### 희소 인덱스

- 시스템이 **새로운 블록을 생성한다면**, 새로운 블록에 나타나는 첫 번째 검색 키 값을 인덱스에 삽입한다.
- 반면, 새로운 레코드가 **그 블록 안에 있는 가장 작은 검색 키 값이라면** 시스템은 그 블록을 가리키고 있는 인덱스 엔트리를 갱신한다.
- **그렇지 않으면 시스템은 인덱스를 바꾸지 않는다.**

<br/>

### 14.2.3.2 삭제, deletion

1. 시스템은 먼저 삭제될 레코드를 **찾는다.**
2. 그 다음 해야할 일은 인덱스의 종류에 따라서 다르다.

<br/>

#### 밀집 인덱스

1. **삭제될 레코드가 특정한 검색 키 값을 가지는 유일한 레코드라면,** 시스템은 인덱스로부터 이와 대응되는 인덱스 엔트리를 삭제한다.
2. 그렇지 않다면,
    1. 만약 인덱스 엔트리가 **똑같은 검색 키 값을 가지는 모든 레코드를 가리키는 포인터를 저장하고 있다면,**  
       시스템은 삭제된 레코드에 대한 포인터를 삭제한다.
    2. 그렇지 않다면 인덱스 엔트리는 검색 키 값을 가지는 첫 번째 레코드에 대한 포인터만 저장하고 있다는 것이다.  
       → **삭제된 레코드가 검색 키 값을 가지는 첫 번째 레코드였다면,** 시스템은 인덱스 엔트리가 다음 레코드를 가리키도록 저장한다.

<br/>

#### 희소 인덱스

1. 만약 인덱스가 **삭제된 레코드의 검색 키 값을 가지는 인덱스 엔트리를 포함하고 있지 않다면** 인덱스에 대해 해야 할 일은 없다.
2. 그렇지 않다면,
    1. (1) 만약 **삭제된 레코드가 그 검색 키를 가지는 유일한 레코드였다면,** 시스템은 대응되는 인덱스 레코드로 교체한다.  
       (2) **다음 검색 키 값이 이미 인덱스 엔트리에 있다면,** 이 엔트리는 교체되는 대신 삭제된다.
    2. 그렇지 않다면 검색 키 값을 위한 인덱스 엔트리는 삭제된 레코드를 가리키고 있다는 것이다.  
       → 시스템은 인덱스 레코드가 똑같은 검색 키 값을 가지는 다음 레코드를 가리키도록 갱신한다.

<br/>

---

<br/>

다계층 인데스를 위한 삽입과 삭제는 위의 구조를 간단히 확장하기만 하면 된다.

<br/>
<br/>

## 14.2.4 보조 인덱스

> 보조 인덱스는 모든 검색 키 값과 모든 레코드에 대한 포인터를 가지는 인덱스 엔트리로 된 **밀집 인덱스**여야 한다.

- 즉, 보조 인덱스는 **모든 레코드에 대한 포인터를 포함해야 한다.**
- 레코드는 **보조 인덱스의 검색 키에 의해서가 아닌, 기본 인덱스의 검색 키에 의해 순서대로 되어 있기 때문에**,  
  똑같은 검색 키의 값을 가지는 나머지 레코드는 파일의 아무 곳에나 흩어져 있을 수 있다.

<br/>

### 비고유 검색 키, nonunique search key

릴레이션에 동일한 검색 키 값을 가지는 레코드가 두 개 이상 존재한다면,  
즉 **두 개 이상의 레코드가 인덱싱 속성에 대해 동일한 값을 가질 수 있다면,** 이러한 검색 키를 `비고유 검색 키`라고 한다.

> 비고유 검색 키에 대해서 보조 인덱스를 구현하려면,  
> 보조 인덱스에 있는 각각의 포인터는 **그 파일에 대한 포인터를 담고 있는 버켓을 가리켜야 한다.**

<br/>

단점

- 임의 I/O 작업이 필요한 간접 참조로 인해 인덱스 접근 시 시간이 더 오래 걸린다.
- 키에 중복이 거의 없거나 전혀 없는 경우, 전체 블록이 해당 버켓에 할당되면 많은 공간 낭비가 발생한다.

<br/>

클러스터링 인덱스 순서에서 연속적으로 스캔하는 것은 능률적이다.  
(파일에 있는 레코드가 인덱스의 순서와 똑같은 순서로 물리적으로 저장되어 있기 때문)

그러나 파일을 보조 키 순서대로 스캔을 시도한다면, 각 레코드를 읽는 것은 디스크로부터 새로운 블록 읽기를 요구하는 것과 같기 때문에 매우 느리다.

<br/>

보조 인덱스는 기본 인덱스의 검색 키가 아닌 다른 키를 사용하는 질의문의 성능을 향상시키지만, 데이터베이스 변경에 상당한 부담을 강요한다.

따라서 보조 인덱스는 검색만을 위한 질의와
데이터 변경의 상대적인 빈도에 대한 평가에 기초해서 결정되어야 한다.

<br/>
<br/>

## 14.2.5 다중 키상의 인덱스

> **두 개 이상의 속성으로 구성된 검색 키**를 `복합 검색 키(composite search key)`라고 한다.

- 검색 키가 하나의 속성이 아니라, 속성의 목록으로 되어 있다.
- 검색 키는 **값의 튜플**인 (a1, … , an) 형식으로 표현될 수 있으며, 이때 인덱스의 속성은 A1, … , An이다.
- 검색 키 값의 순서는 `사전적 순서(lexicographic ordering)`이다.
