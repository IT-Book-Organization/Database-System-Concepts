# 13.2 파일 구성

<br/>

## Database > File > Record > Field

- The `database` is stored as a collection of `files`.
- Each `file` is a sequence of `records`.
- A `record` is a sequence of `fields`.

<br/>

하나의 데이터베이스는 내부적으로 기반 운영체제가 관리하는 많은 다른 파일에 대응하며, 이 파일은 디스크 안에 영구적으로 저장된다.

> `파일(file)`은 일련의 레코드로서, 논리적으로 구성된다.

<br/>

> `블록(block)`이라고 불리는 **고정 길이(fixed-length) 저장 단위**로 각 파일을 논리적으로 분할한다.

이는 저장 장소 할당과 데이터 전송의 단위이다.

대부분의 데이터베이스는 기본으로 4~8킬로바이트의 블록 크기를 사용한다.

<br/>

> 한 개의 블록은 여러 `레코드(record)`을 포함한다.

정확히 어떤 레코드 집합이 같은 블록에 있어야 하는지에 대한 결정은 물리적 데이터 구성의 형태가 한다.

<br/>

> 레코드는 여러 `필드(field)`를 포함한다.

<p align="center"><img width="250" alt="record" src="https://github.com/IT-Book-Organization/Database-System-Concepts/assets/86337233/292dc4cd-f653-4a37-8c64-1db82bda99c6">

<br/>
<br/>

---

<br/>

**블록보다 더 큰 레코드는 없다**고 가정한다.

- 이 가정은 대부분의 데이터 처리 응용 프로그램을 고려할 때 현실적이다.
- 이미지와 같이 블록보다 훨씬 큰 대용량의 데이터 항목은 별도로 저장한 다음, 레코드 안에 해당 데이터 항목에 대한 포인터를 저장함으로써 다룬다.

<br/>

**단일 블록은 각 레코드를 완전히 포함해야 한다.**

- 이는 어떤 레코드도 한 블록에 부분적으로 포함되거나 또 다른 레코드에 부분적으로 포함되지 않는다는 것을 의미한다.

<br/>

---

<br/>

관계형 데이터베이스에서 서로 다른 릴레이션의 튜플은 일반적으로 다른 크기를 가진다.

<br/>

데이터베이스에 파일을 매핑하기 위한 두 가지 방법

1. 여러 파일을 사용하면서 주어진 파일 내에 `고정 길이` 레코드만 저장한다.
2. 파일을 구조적으로 저장하여 `가변 길이`로 레코드를 저장한다.

고정 길이 레코드로 구성된 파일은 가변 길이 레코드 파일보다 구현하기 더 쉽지만, 가변 길이의 경우에 더 많은 다양한 기법들을 적용할 수 있게 된다.

<br/>
<br/>
<br/>

# 13.2.1 고정 길이 레코드

대학교 데이터베이스의 instructor 레코드 파일의 각 레코드를 의사 코드로 다음과 같이 정의할 수 있다.

```sql
type instructor = record
                    ID varchar(5);
                    name varchar(20);
                    dept_name varchar(20);
                    salary numeric(8, 2);
                  end
```

<br/>

각 문자는 1바이트를, numeric(8, 2)형은 8바이트를 차지한다고 가정한다면, instructor 레코드의 길이는 53바이트다.

이러한 고정 길이 파일을 구성하는 간단한 방법은 첫 번째 레코드를 위해 첫 번째 53바이트를 사용하고,  
두 번째 레코드를 위해 그다음 53바이트를 사용하는 등등이다.

<p align="center"><img width="500" alt="고정 길이 레코드" src="https://github.com/IT-Book-Organization/Database-System-Concepts/assets/86337233/d2006add-2bb9-4e0f-92ba-4680659b9697">

<br/>
<br/>

---

<br/>

> Store record `i` starting from byte `n * (i-1)`, where `n` is the size of each record.

아래 예시는 레코드의 길이가 100바이트라고 가정했을 경우에 대한 것이다.


<p align="center"><img width="800" alt="record access" src="https://github.com/IT-Book-Organization/Database-System-Concepts/assets/86337233/da4025f3-5eae-4cb0-8a9b-a478595f7d2c">

<br/>
<br/>
<br/>

## 문제점

이 방법은 두 가지 문제점을 지닌다.

<br/>

> 1️⃣ 만약 블록 크기가 53의 배수가 되지 않는다면 몇몇 레코드는 블록 경계를 넘게 된다

즉, 레코드 일부분은 어떤 블록에 저장되고 나머지 부분은 다른 블록에 저장될 것이므로 해당 레코드를 읽거나 쓰기 위해서는 두 블록에 모두 접근해야 한다.

이를 피하려면 한 블록에 완전히 채울 수 있는 만큼의 블록만 레코드를 할당해야 한다. (남은 바이트는 사용하지 않은 채 남김)

<br/>

> 2️⃣ 레코드를 삭제하기가 어렵다

삭제할 레코드가 차지하는 공간은 그 파일의 다른 레코드로 채우거나, 그 공간을 무시할 수 있도록 레코드를 삭제했다는 표시를 해야 한다.

<br/>
<br/>

## 레코드의 삭제

가능한 방법은 총 3가지가 존재한다.

<br/>

> 1️⃣ 한 레코드를 삭제할 때 이 레코드 뒤에 있는 모든 레코드를 바로 **전 레코드가 차지한 공간으로 이동시킨다.**

아래 그림은 레코드 3이 삭제되고 마지막 레코드가 이동한 상태를 나타낸다.

<p align="center"><img width="500" alt="deletion 1" src="https://github.com/IT-Book-Organization/Database-System-Concepts/assets/86337233/2b1cd72c-bdd7-441d-a20f-89c34ab1edc7">

<br/>
<br/>

이 방법에서는 많은 수의 레코드가 이동해야 할 수 있기 때문에,  
아래 그림처럼 **삭제한 레코드가 있었던 공간에 파일의 마지막 레코드를 단순히 이동**하는 게 더 쉬울 수 있다.

<p align="center"><img width="500" alt="deletion 2" src="https://github.com/IT-Book-Organization/Database-System-Concepts/assets/86337233/99b2c6a2-702e-4001-a9c4-543b21bdcbaa">

<br/>
<br/>

하지만 이처럼 삭제한 레코드가 있었던 빈 곳, 즉 `자유 공간`을 채우기 위해 레코드를 이동하게 되면 부차적인 블록 접근이 필요하기에 바람직하지 않다.

<br/>

> 2️⃣ 삭제한 레코드가 있었던 공간을 비워 둔 채, 재사용하기 전 다음에 삽입할 레코드를 기다리게 한다.  
> → new 레코드를 해당 빈 자리에 추가한다.

하지만 이러한 이용 가능 공간을 찾기가 어렵기 때문에, 삭제한 레코드를 표시하는 것만으로는 충분하지 않을 것다.

따라서 추가적인 구조를 생각해 볼 필요가 있다.

<br/>

> 3️⃣ 자유 리스트(free list)를 사용한다.

파일의 앞부분에 일부 바이트를 할당해 `파일 헤더(file header)`를 만들어서, 해당 파일에 대한 다양한 정보를 저장한다.

여기에 삭제된 첫 번째 레코드의 주소를 저장하고, 이 레코드를 사용해서 이용 가능한 두 번째(즉 다음) 레코드의 주소를 저장하고, …  
이런 식으로 계속해 나가면 된다.

<br/>

이렇게 저장한 레코드 주소는 레코드의 위치를 가리키므로 해당 주소를 `포인터(pointer)`로 생각할 수 있으며,  
이 삭제한 레코드는 `연결 리스트(linked list)`를 형성한다.

이는 종종 `자유 리스트(free list)`로 언급하기도 한다.

<p align="center"><img width="550" alt="deletion 3" src="https://github.com/IT-Book-Organization/Database-System-Concepts/assets/86337233/d3c3dfe6-db5b-4a3d-8a88-c1c0c1d60e56">

<br/>
<br/>

- 새로운 레코드를 삽입할 대 헤더가 가리키는 레코드를 사용한다.
- 그다음 헤더의 포인터를 다음 이용 가능한 레코드를 가리키도록 바꾼다.
- 이용 가능 공간이 없다면 이 파일 끝에 새로운 레코드르 추가한다.

<br/>

---

<br/>

고정 길이 레코드에서는 삭제한 레코드가 이용할 수 있는 공간은 정확하게 새로운 레코드를 삽입하는 데 필요한 공간이 된다.

따라서 고정된 길이의 레코드를 저장한 파일의 삽입과 삭제는 구현이 간단하다.

<br/>

그러나 가변 길이 레코드를 파일에 저장한다면 이런 일치가 더는 유효하지 않게 된다.

<br/>
<br/>
<br/>

# 13.2.2 가변 길이 레코드

데이터베이스 시스템에서 `가변 길이 레코드(variable-length record)`가 필요한 몇 가지 상황이 있다.

- 파일 내에 여러 레코드 유형의 존재
- 가변 길이 필드의 존재 (e.g., varchar)
- 배열 혹은 다중 집합(multiset)과 같은 반복적인 필드를 포함하는 레코드 유형의 존재

<br/>

---

<br/>

가변 길이 레코드를 구현하기 위한 다양한 기법이 존재하며, 이들은 아래의 두 가지 서로 다른 문제를 해결해야 한다.

1. 속성이 가변 길이인 경우에도 **개별 속성을 쉽게 추출할 수 있는** 방식으로 하나의 레코드를 표현하는 방법
2. **블록 내의 레코드를 쉽게 추출할 수 있도록** 블록 내에 가변 길이 레코드를 저장하는 방법

<br/>
<br/>

## 가변 길이 레코드의 표현

가변 길이의 속성을 지닌 레코드의 표현은 일반적으로 두 부분으로 구성된다.

<br/>

> 1️⃣ 구조가 같은 릴레이션의 모든 레코드에 대해 같은 **고정 길이 정보**를 갖는 처음 부분

→ 고정 길이 속성에 해당 값을 저장하는 데 필요한 많은 수의 바이트마늠을 해당 고정 길이 속성에 할당한다.

<br/>

> 2️⃣ **가변 길이 속성의 내용**으로 구성된 그다음 부분

→ 레코드의 처음 부분에서 `[offset, length]`의 쌍으로 표현된다.

- `offset` : 레코드 내의 속성이 시작되는 부분을 위한 데이터
- `length` : 가변 길이 속성의 바이트의 길이 (size of data)

<br/>

---

<br/>

이러한 레코드 표현의 예시는 아래와 같다.

e.g., instructor 레코드

<br/>

ID, name, dept_name

- 가변 길이의 문자열 → 각 문자열은 자신이 가지는 수만큼의 바이트를 지닌다.
- offset과 length 값을 속성당 2바이트씩, 총 4바이트를 저장한다고 가정한다.

<br/>

salary

- 고정 길이 숫자
- 8바이트로 해당 속성을 저장한다고 가정한다.

<br/>

<p align="center"><img width="650" alt="가변 길이 레코드" src="https://github.com/IT-Book-Organization/Database-System-Concepts/assets/86337233/d586bdc9-e4b0-4d13-a72d-7f683cc857e6">

<br/>
<br/>

### 널 비트맵, null bitmap

위 그림에서 어떤 레코드의 속성이 null 값을 가지는지를 나타내는 `널 비트맵(null bitmap)`의 사용도 볼 수 있다.

특정한 레코드에서 만약 salary의 값이 null이면 **비트맵의 네 번째 비트는 1로 설정되고**, 12~19바이트로 저장될 salary의 값은 무시될 것이다.

<br/>

일부 표현에서 레코드의 시작 부분에 널 비트맵을 저장하고, null인 속성을 위해 값이나 offset, length와 같은 데이터를 전혀 저장하지 않는다.

이런 표현에서는 레코드의 속성을 추출하기 위한 여분의 작업 비용에서 저장 장치의 공간을 절약하게 되므로,  
대부분의 필드가 null 값을 갖는 레코드를 사용하는 여러 응용 프로그램에 특히 유용하다.

<br/>
<br/>

## 슬롯 페이지 구조, slotted-page structure

`슬롯 페이지 구조(slotted-page structure)`는 블록 내의 레코드를 구성하는 데 흔히 사용된다. (여기서 “페이지”는 “블록”과 같은 의미로 사용한다.)

<br/>

<p align="center"><img width="600" alt="slotted-page structure" src="https://github.com/IT-Book-Organization/Database-System-Concepts/assets/86337233/ae387059-73ae-43bd-99cd-2b7f2a0f4f80">

<br/>
<br/>

각 블록의 시작에는 다음의 정보를 저장하는 헤더가 있다.

- 헤더가 있는 레코드 엔트리의 수
- 블록에서 빈 곳의 끝
- 각 레코드의 위치와 크기를 포함하고 있는 엔트리 배열

<br/>

### 레코드의 삽입

> 실제 레코드는 블록의 끝에서부터 **인접하게(contiguously)** 할당되며,  
> 블록에서 빈 곳은 헤더 배열에 있는 마지막 엔트리와 첫 번째 레코드 사이에서 연속적이다.

어떤 한 레코드를 삽입하면 **빈 곳 끝에 이 레코드를 위한 공간을 할당**하고, 이 레코드의 크기와 위치를 포함하는 엔트리를 헤더에 추가한다.

<br/>

### 레코드의 삭제

1. 레코드를 삭제하면 해당 레코드가 차지하고 있던 공간을 비우고, 관련 엔트리를 **삭제한 상태**(예를 들어, 크기는 -1로 표시)로 명시한다.
2. 삭제한 레코드 앞쪽에 있는 레코드를 이동한다.
    - 이를 통해 삭제한 레코드가 차지하고 있었던 공간이 빈 곳이 되어, 모든 빈 곳은 다시 헤더 배열의 마지막 엔트리와 첫 번째 레코드 사이에 있게 된다.

<br/>

---

<br/>

> 헤더에 있는 빈 공간의 끝을 가리키는 포인터를 상황에 맞게 갱신해야 한다.

<br/>

> 블록의 크기가 제한되어 있으므로 레코드를 이동하는 비용은 크게 들지 않는다.

블록의 크기는 보통 4~8킬로바이트다.


<br/>

> 레코드를 직접 가리키는 포인터는 없도록 해야 하며,  
> 포인터는 레코드의 실제 위치를 포함하고 있는 헤더 안에 있는 엔트리를 가리키도록 해야 한다.

이러한 수준의 우회(indirection)는 레코드에 대한 간접 포인터를 지원하면서, 블록의 공간을 단편화하는 것을 막기 위해 레코드를 이동할 수 있도록 해준다.

<br/>
<br/>
<br/>

# 13.2.3 대형 객체 저장 방법

데이터베이스는 디스크 블록보다 훨씬 큰 데이터를 종종 저장한다.

<br/>

대부분의 관계형 데이터베이스는 내부적으로 한 레코드의 크기가 한 블록의 크기를 넘지 않도록 제한한다.

해당 `대형 객체(large object)`는 레코드의 다른 소형 속성과는 별도로 저장하며, **대형 객체에 대한 논리 포인터를 해당 객체를 포함하는 레코드에 저장한다.**

<br/>

대형 객체를 저장하는 방법에는 두 가지가 존재한다.

1. 데이터베이스가 관리하는 파일 시스템 영역의 파일로 저장한다.
2. 데이터베이스가 저장하고 관리하는 파일 구성으로 저장한다.
    - 데이터베이스 내 대형 객체를 `B+-tree` 파일 구성을 사용해서 선택적으로 표현할 수 있다. (14.4.1절)
    - B+-tree 파일 구성은 그 객체 내의 임의 위치에 대한 효율적인 접근을 가능하게 한다.

<br/>
<br/>

## 성능 이슈

데이터베이스에 매우 큰 객체를 저장하는 데서 오는 몇 가지 성능에 대한 이슈들은 다음과 같이 존재한다.

1. 대형 객체를 데이터베이스 인터페이스를 통해서 접근하는 것이 효율적인가?
2. 데이터베이스 백업의 크기 증가
    - 많은 기업이 주기적으로 `데이터베이스 덤프(dump)`, 즉 데이터베이스의 백업 복사본을 만드는데  
      데이터베이스에 대형 객체를 저장하면 데이터베이스 덤프의 크기가 매우 증가할 것이다.

<br/>

### 해결법

> 많은 응용 프로그램은 크기가 매우 큰 객체를 **데이터베이스 외부의 파일 시스템에 저장한다.**

이럴 때 응용 프로그램은 파일 이름(일반적으로 파일 시스템에서 경로)을 데이터베이스 내 레코드의 속성으로 저장할 수 있다.

<br/>

하지만 이렇게 하면 문제들이 또다시 발생하게 된다.

- 데이터베이스의 파일 이름이 존재하지 않는 파일을 가리키게 되며, 파일이 삭제되었기 때문에 외래 키 제약 조건을 위반하는 형태가 된다.
- 데이터베이스 권한 제어는 파일 시스템에 저장된 데이터에는 적용되지 않는다.

<br/>

> 따라서 일부 데이터베이스는 **데이터베이스와의 파일 시스템 통합**을 제공한다.

- 제약 조건을 충족하는지를 확인하고 데이터베이스 접근 권한을 적용하도록 한다.
- 즉, 파일 시스템 인터페이스와 데이터베이스 SQL 인터페이스 모두에서 파일에 접근할 수 있는 것이다.

e.g., Oracle : SecureFiles 및 Database File System 특성을 이용해 이러한 통합을 지원한다.
