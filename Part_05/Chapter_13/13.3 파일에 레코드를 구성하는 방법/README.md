# 13.3 파일에 레코드를 구성하는 방법

<br/>

> `릴레이션(relation)` = `레코드(record)`들의 집합

<br/>

파일 안에 레코드를 구성하는 몇 가지 가능한 방법은 다음과 같다.

- 힙 파일 구성, Heap file organization
- 순차 파일 구성, Sequential file organization
- 다중 테이블 군집 파일 구성, Multitable clustering file organization
- B+-트리 파일 구성, B+-tree file organization
- 해싱 파일 구성, Hashing file organization

<br/>
<br/>
<br/>

# 13.3.1 힙 파일 구성

레코드는 릴레이션에 해당하는 파일의 어디에나 저장될 수 있다.

> 파일 안에 레코드를 위한 공간만 있다면 임의의 레코드는 어디든지 놓일 수 있으며, 레코드의 순서는 없다.

<br/>
<br/>

## 레코드의 삽입

<p align="center"><img width="700" alt="힙 파일 구성" src="https://github.com/IT-Book-Organization/Database-System-Concepts/assets/86337233/69101809-aa3c-4460-9949-25b2c616acbb">

<br/>
<br/>

레코드를 파일에 삽입할 때, 항상 파일의 끝부분에 추가하도록 할 수 있다.

그러나 **레코드를 삭제하면 만들어진 빈 곳**을 사용하여 새 레코드를 저장하는 것이 더 좋다.

<br/>

### 여유 공간 맵, free-space map

대부분 데이터베이스는 `여유 공간 맵(free-space map)`이라고 하는 공간 효율적 데이터 구조를 사용하여 레코드를 저장할 여유 공간이 있는 블록을 추적한다.

- 여유 공간 맵은 릴레이션의 각 블록에 대해 한 개의 엔트리를 포함하는 배열로 흔히 나타낸다.
- 각 엔트리는 비율 f를 표현하는데, 이는 **최소 비율 f만큼이 해당 블록 공간에 비어 있어야 한다**는 것을 뜻한다.

<br/>

> 배열은 파일에 저장되고, 파일의 블록은 필요할 때 메모리로 가져온다.

레코드를 삽입, 삭제 또는 그 크기를 변경할 때마다 엔트리 값에 영향을 줄 만큼 점유 비율이 변경되면 여유 공간 맵에서 엔트리를 갱신한다.

<br/>

e.g., 16개의 블록이 있는 파일에 대한 여유 공간 맵

- 점유 비율을 저장하기 위해 3비트를 사용한다고 가정하자.
- 위치 i의 값을 8(= 2^3)로 나누어 블록 i의 여유 공간 비율을 구해야 한다.
    - e.g., 7 = 해당 블록에서 최소 7/8의 공간이 비어 있다.
- 한 페이지가 4KB라고 가정한다면, unit size for the free spaces : 512바이트(= 4KB / 8)

<br/>

<p align="center"><img width="450" alt="여유 공간 맵" src="https://github.com/IT-Book-Organization/Database-System-Concepts/assets/86337233/a6f0f697-2496-4401-8538-7ae67d550c95">

<br/>
<br/>

1. 데이터베이스는 주어진 크기의 새 레코드를 저장할 블록을 찾기 위해, 여유 공간 맵을 스캔하여 해당 레코드를 저장할 충분한 여유 공간이 있는 블록을 찾는다.
2. 만약 적당한 블록이 없다면 릴레이션에 새로운 블록을 할당한다.

<br/>

### 2계층 여유 공간 맵

여유 공간이 충분한 블록을 찾는 작업의 속도를 높이기 위해 **2계층의 여유 공간 맵**을 만들 수 있다.

2단계 여유 공간 맵은 기존의 여유 공간 맵의 n개 엔트리 중 최댓값만을 저장하는 것으로 구현할 수 있다.

아래 배열은 위의 예시에 대한 `2단계 여유 공간 맵`을 나타낸 것이다.

<p align="center"><img width="130" alt="2단계 여유 공간 맵" src="https://github.com/IT-Book-Organization/Database-System-Concepts/assets/86337233/92872dee-71b1-4dba-8118-76d57eed5541">

<br/>
<br/>

2단계 여유 공간 맵에서 충분한 여유 공간을 가진 적절한 엔트리가 발견되면, 기본 여유 공간 맵에서 해당하는 엔트리들을 검사하며 여유 공간이 충분한 블록을 찾으면 된다.

<br/>

매우 큰 릴레이션을 다루기 위해 같은 아이디어를 사용하여 2계층 이상의 여유 공간 맵을 만들 수 있다.

<br/>
<br/>

### 여유 공간 맵의 갱신

맵의 엔트리를 갱신할 때마다 여유 공간 맵을 디스크에 쓰는 것은 비용이 많이 들 수 있다.

따라서 **여유 공간 맵을 주기적으로 쓰게 되는데**, 이로 인해 디스크의 여유 공간 맵이 최신이 아닐수도 있다.

즉, 여유 공간 맵은 블록에 여유 공간이 없을 때도 여유 공간이 있다고 할 수 있으며,  
이 오류는 블록을 가져올 때 감지가 된다. 이는 여유 공간 맵에서 추가로 검색하여 해결할 수 있다.

반면에 여유 공간 맵은 블록에 여유 공간이 없다고 할 수도 있는데, 이를 해결하기 위해 릴레이션을 주기적으로 스캔하고 여유 공간 맵을 다시 계산하여 디스크에 기록한다.

<br/>
<br/>
<br/>

# 13.3.2 순차 파일 구성

> 레코드의 효율적인 처리를 위해 일부 `검색 키(search key)`**를 기반으로 정렬한 순서로** `순차 파일(sequential file)`을 설계한다.

<br/>

### 검색 키

- `검색 키(search key)` 는 특정 속성이나 속성들의 집합으로, 정렬의 기준이 된다.
- 반드시 주 키이거나 수퍼 키일 필요는 없다.

<br/>

> 각 레코드는 다음 레코드를 검색 키의 순서로 **포인터를 통해 연결한다.**

<p align="center"><img width="500" alt="순차 파일 구성" src="https://github.com/IT-Book-Organization/Database-System-Concepts/assets/86337233/597d74bb-7755-42a0-8289-5a3efdd7aa32">

<br/>
<br/>

## 레코드의 삭제와 삽입

레코드를 삽입하고 삭제한 대로 물리적 순서를 유지하기는 어렵다.

한 번의 삽입이나 삭제 때문에 많은 레코드를 이동하는 것은 비용이 많이 들기 때문이다.

<br/>

### 레코드의 삭제

레코드의 삭제는 `포인터 체인`을 이용하여 관리할 수 있다.

(아래 사진에서 붉은색 부분 참고)

<br/>

### 레코드의 삽입

1. 검색 키 순서로 볼 때 삽입할 레코드 바로 앞에 위치하는 레코드를 파일에서 찾는다.
2. (1) 찾은 레코드와 같은 블록 내에 빈 레코드(즉 삭제한 후 빈 공간)가 있다면 거기에 새로운 레코드를 삽입한다.  
   (2) 그렇지 않다면 `오버플로 블록(overflow block)`에 새로운 레코드를 삽입한다.  
   → 어느 경우든, 레코드를 검색 키 순서로 연결하기 위해 포인터를 조정한다.

(아래 사진에서 푸른색 부분 참고)

<p align="center"><img width="600" alt="순차 파일 구성 - 삭제와 삽입" src="https://github.com/IT-Book-Organization/Database-System-Concepts/assets/86337233/97112361-8088-458e-a145-e7e7acbfd2c1">

<br/>
<br/>

## 파일의 재구성

상대적으로 오버플로 블록에 저장할 필요가 있는 레코드가 거의 없다면 위의 방법은 잘 동작한다.

하지만 검색 키 순서와 물리적 순서 사이의 일치를 시간이 지남에 따라 완전히 잃어버릴 수가 있어, 이 경우 순차적인 처리가 훨씬 비효율적으로 될 수 있다.

이 시점에서는 다시 물리적으로 순차적인 순서가 되도록 파일을 `재구성(reorganized)`해야 한다.

- 재구성 작업은 비용이 많이 든다.
- 이 작업은 시스템 작업량이 낮을 때 해야 한다.
- 재구성이 필요한 빈도는 새로운 레코드의 삽입 빈도에 따라 다르다.

<br/>

14.4.1절에서 설명하는 `B+-트리 파일 구성`은 삽입, 삭제 및 갱신이 많이 일어날 때도 비용이 많이 드는 재구성 없이 효율적인 정렬 접근이 가능하다.
